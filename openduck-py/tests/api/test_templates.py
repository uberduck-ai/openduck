from datetime import datetime, timedelta

from fastapi import HTTPException
from fastapi.testclient import TestClient
from sqlalchemy import select
import pytest

from openduck_py.routers.main import app
from openduck_py.models import DBTemplatePrompt, DBTemplateDeployment
from openduck_py.routers.templates import check_variables, DEFAULT_MODEL
from openduck_py.utils.utils import equal_dicts


client = TestClient(app)


class TestTemplates:
    endpoint = "/templates"

    def test_template_prompt_creation(self, db_session, user_token, mocker):
        patch = mocker.patch("uberduck_py.routers.templates.aio_rate_limit")
        patch.return_value = None
        template_data = {
            "display_name": "Test Template Create",
            "prompt": "This is a test prompt.",
            "variables": [],
            "values": [],
        }
        create_response = client.post(
            f"{self.endpoint}/prompts",
            json=template_data,
            cookies=dict(access_token=f"Bearer {user_token}"),
        )
        assert create_response.status_code == 200
        url_name = "test-template-create"
        # The uuid is autogenerated by the backend
        assert "uuid" in create_response.json()

        # Assert that template is saved in the database
        template = (
            db_session.query(DBTemplatePrompt).filter_by(url_name=url_name).first()
        )
        assert template is not None
        assert template.url_name == url_name
        assert template.prompt["messages"][0]["content"] == template_data["prompt"]

        # check created at date
        time_diff = abs(template.created_at - datetime.utcnow())
        assert time_diff <= timedelta(minutes=1)

    def test_create_wrong_model(self, db_session, user_token, mocker):
        patch = mocker.patch("uberduck_py.routers.templates.aio_rate_limit")
        template_data = {
            "display_name": "Test Template Create",
            "prompt": "Test Prompt",
            "variables": [],
            "values": [],
            "model": "incorrect-model",
        }
        create_response = client.post(
            f"{self.endpoint}/prompts",
            json=template_data,
            cookies=dict(access_token=f"Bearer {user_token}"),
        )
        assert create_response.status_code == 422

    def test_create_wrong_vars(self, db_session, user_token, mocker):
        patch = mocker.patch("uberduck_py.routers.templates.aio_rate_limit")
        template_data = {
            "display_name": "Wrong Variables",
            "prompt": "Hi, my name is {{name}}, I live in {{city}}",
            "variables": ["wrong", "variable", "names"],
            "values": [{"wrong": "", "variable": "", "names": ""}],
        }
        create_response = client.post(
            f"{self.endpoint}/prompts",
            json=template_data,
            cookies=dict(access_token=f"Bearer {user_token}"),
        )
        assert create_response.status_code == 400

    def test_template_prompt_creation_duplicate(
        self, db_session, user_token, prompt_template, mocker
    ):
        patch = mocker.patch("uberduck_py.routers.templates.aio_rate_limit")
        # When trying to create a prompt with a name that already exists in the table, it should
        # return error 400
        template_data = {
            "display_name": "Test Template",
            "prompt": "This is a test prompt. {{test_var1}} {{test_var2}} {{test_var3}}",
            "variables": ["test_var1", "test_var2", "test_var3"],
            "values": [{"test_var1": "", "test_var2": "", "test_var3": ""}],
        }
        create_response = client.post(
            f"{self.endpoint}/prompts",
            json=template_data,
            cookies=dict(access_token=f"Bearer {user_token}"),
        )
        print("create response", create_response.json())
        assert create_response.status_code == 400
        assert create_response.json()["detail"] == "Prompt must have a unique name"

    def test_template_prompt_edit(
        self, db_session, user_token, prompt_template, mocker
    ):
        patch = mocker.patch("uberduck_py.routers.templates.aio_rate_limit")
        updated_data = {
            "display_name": "Updated Test Template",
            "prompt": "This is an updated test prompt.",
            "variables": [],
            "values": [],
            "model": DEFAULT_MODEL,
        }
        edit_response = client.patch(
            f"{self.endpoint}/prompts/{prompt_template.uuid}",
            json=updated_data,
            cookies=dict(access_token=f"Bearer {user_token}"),
        )
        updated_url_name = "updated-test-template"
        assert edit_response.status_code == 200
        assert edit_response.json() == {
            "uuid": prompt_template.uuid,
            "display_name": "Updated Test Template",
            "url_name": updated_url_name,
            "created_at": int(prompt_template.created_at.timestamp()),
            "variables": [],
            "values": [],
            "prompt": {
                "messages": [
                    {
                        "content": "This is an updated test prompt.",
                        "role": "user",
                    }
                ]
            },
            "completion": "",
            "model": DEFAULT_MODEL,
        }

        updated_template = (
            db_session.query(DBTemplatePrompt)
            .filter_by(url_name=updated_url_name)
            .first()
        )
        db_session.refresh(prompt_template)
        assert updated_template is not None
        assert updated_template.url_name == updated_url_name
        assert (
            updated_template.prompt["messages"][0]["content"] == updated_data["prompt"]
        )
        assert updated_template.meta_json == {"variables": [], "values": []}
        assert updated_template.model == DEFAULT_MODEL

    def test_template_prompt_partial_edit(
        self, db_session, user_token, prompt_template, mocker
    ):
        patch = mocker.patch("uberduck_py.routers.templates.aio_rate_limit")
        updated_data = {
            "prompt": "This is an updated test prompt.",
        }
        edit_response = client.patch(
            f"{self.endpoint}/prompts/{prompt_template.uuid}",
            json=updated_data,
            cookies=dict(access_token=f"Bearer {user_token}"),
        )
        assert edit_response.status_code == 200
        assert edit_response.json() == {
            "uuid": prompt_template.uuid,
            "display_name": "Test Template",
            "url_name": "test-template",
            "created_at": int(prompt_template.created_at.timestamp()),
            "variables": ["test_var1", "test_var2", "test_var3"],
            "values": [{"test_var1": "", "test_var2": "", "test_var3": ""}],
            "prompt": {
                "messages": [
                    {
                        "content": "This is an updated test prompt.",
                        "role": "user",
                    }
                ]
            },
            "completion": "",
            "model": DEFAULT_MODEL,
        }

        updated_template = (
            db_session.query(DBTemplatePrompt)
            .filter_by(url_name=prompt_template.url_name)
            .first()
        )
        db_session.refresh(prompt_template)
        assert updated_template is not None
        assert updated_template.url_name == prompt_template.url_name
        # Only the prompt is changed in the updated template
        assert (
            updated_template.prompt["messages"][0]["content"] == updated_data["prompt"]
        )
        assert updated_template.meta_json == prompt_template.meta_json
        assert updated_template.model == prompt_template.model
        assert updated_template.display_name == prompt_template.display_name

    def test_template_prompt_edit_duplicate_vars(
        self, db_session, user_token, prompt_template, mocker
    ):
        patch = mocker.patch("uberduck_py.routers.templates.aio_rate_limit")
        updated_data = {
            "prompt": "This is an updated test prompt with duplicate variables {{test_var}}, {{test_var}}, and {{test_var}}",
            "variables": ["test_var", "test_var", "test_var"],
        }
        edit_response = client.patch(
            f"{self.endpoint}/prompts/{prompt_template.uuid}",
            json=updated_data,
            cookies=dict(access_token=f"Bearer {user_token}"),
        )
        assert edit_response.status_code == 400
        assert edit_response.json() == {"detail": "Input variables contain duplicates"}

    @pytest.mark.parametrize(
        "table,template_fixture",
        [
            ("deployments", "deployment_template"),
            ("prompts", "prompt_template"),
        ],
    )
    def test_template_prompt_get(
        self, db_session, user_token, request, table, template_fixture, mocker
    ):
        patch = mocker.patch("uberduck_py.routers.templates.aio_rate_limit")
        template = request.getfixturevalue(template_fixture)
        identifier = template.url_name if table == "deployments" else template.uuid
        # Test for all uuids
        get_response = client.get(
            f"{self.endpoint}/{table}",
            cookies=dict(access_token=f"Bearer {user_token}"),
        )
        assert get_response.status_code == 200
        result_json = {
            "templates": [
                {
                    "uuid": template.uuid,
                    "display_name": "Test Template",
                    "url_name": "test-template",
                    "created_at": int(template.created_at.timestamp()),
                    "variables": ["test_var1", "test_var2", "test_var3"],
                    "values": [{"test_var1": "", "test_var2": "", "test_var3": ""}],
                    "prompt": {
                        "messages": [
                            {
                                "content": "This is a test prompt. {{test_var1}} {{test_var2}} {{test_var3}}",
                                "role": "user",
                            }
                        ]
                    },
                    "completion": "",
                    "model": template.model,
                }
            ]
        }
        assert equal_dicts(get_response.json(), result_json, ["uuid", "completion"])

        # Test for a single uuid
        get_response = client.get(
            f"{self.endpoint}/{table}/{identifier}",
            cookies=dict(access_token=f"Bearer {user_token}"),
        )
        assert get_response.status_code == 200
        assert get_response.json() == result_json

    @pytest.mark.parametrize(
        "url_name,user_token_fixture",
        [
            ("wrong-url-name", "user_token"),
            ("updated-test-template", "user_2_token"),
        ],
    )
    def test_template_edit_not_found(
        self,
        request,
        db_session,
        url_name,
        user_token_fixture,
        prompt_template,
        mocker,
    ):
        patch = mocker.patch("uberduck_py.routers.templates.aio_rate_limit")
        user_token = request.getfixturevalue(user_token_fixture)
        updated_data = {
            "display_name": "Updated Test Template",
            "prompt": "This is an updated test prompt.",
            "variables": [],
        }
        edit_response = client.patch(
            f"{self.endpoint}/prompts/{url_name}",
            json=updated_data,
            cookies=dict(access_token=f"Bearer {user_token}"),
        )
        assert edit_response.status_code == 404
        assert edit_response.json()["detail"] == "Template not found"

    @pytest.mark.parametrize(
        "table,template_fixture",
        [
            ("deployments", "deployment_template"),
            ("prompts", "prompt_template"),
        ],
    )
    def test_template_prompt_delete(
        self,
        db_session,
        request,
        table,
        template_fixture,
        user_token,
        user_1,
        mocker,
    ):
        patch = mocker.patch("uberduck_py.routers.templates.aio_rate_limit")
        template = request.getfixturevalue(template_fixture)
        identifier = template.url_name if table == "deployments" else template.uuid
        print("Identifier: ", identifier)
        delete_response = client.delete(
            f"{self.endpoint}/{table}/{identifier}",
            cookies=dict(access_token=f"Bearer {user_token}"),
        )
        db_session.refresh(template)
        assert delete_response.json() == {"status": "OK"}
        assert delete_response.status_code == 200

        if table == "deployments":
            DB = DBTemplateDeployment
        else:
            DB = DBTemplatePrompt
        query = select(DB).filter(
            DB.url_name == template.url_name,
            DB.user_id == user_1.id,
        )
        deleted_prompt = db_session.execute(query).scalars().one()
        assert deleted_prompt.deleted_at is not None
        assert deleted_prompt.user_id == template.user_id
        assert deleted_prompt.url_name == template.url_name
        assert deleted_prompt.display_name == template.display_name
        assert deleted_prompt.prompt == template.prompt
        assert deleted_prompt.created_at == template.created_at
        assert deleted_prompt.meta_json == template.meta_json
        assert deleted_prompt.model == template.model

    @pytest.mark.parametrize(
        "table,template_fixture",
        [
            ("deployments", "deployment_template_deleted"),
            ("prompts", "prompt_template_deleted"),
        ],
    )
    def test_delete_already_deleted(
        self, db_session, user_token, request, table, template_fixture, mocker
    ):
        patch = mocker.patch("uberduck_py.routers.templates.aio_rate_limit")
        template = request.getfixturevalue(template_fixture)
        identifier = template.url_name if table == "deployments" else template.uuid
        delete_response = client.delete(
            f"{self.endpoint}/{table}/{identifier}",
            cookies=dict(access_token=f"Bearer {user_token}"),
        )
        assert delete_response.status_code == 404
        assert delete_response.json() == {"detail": "Template not found"}

    def test_edit_prompt_already_deleted(
        self, db_session, user_token, prompt_template_deleted, mocker
    ):
        patch = mocker.patch("uberduck_py.routers.templates.aio_rate_limit")
        edit_response = client.patch(
            f"{self.endpoint}/prompts/{prompt_template_deleted.uuid}",
            json={},
            cookies=dict(access_token=f"Bearer {user_token}"),
        )
        assert edit_response.status_code == 404
        assert edit_response.json() == {"detail": "Template not found"}

    @pytest.mark.parametrize(
        "url_name,user_token_fixture",
        [
            ("wrong-url-name", "user_token"),
            ("updated-test-template", "user_2_token"),
        ],
    )
    def test_delete_deployment_not_found(
        self,
        request,
        db_session,
        url_name,
        user_token_fixture,
        prompt_template,
        mocker,
    ):
        patch = mocker.patch("uberduck_py.routers.templates.aio_rate_limit")
        user_token = request.getfixturevalue(user_token_fixture)
        edit_response = client.delete(
            f"{self.endpoint}/deployments/{url_name}",
            cookies=dict(access_token=f"Bearer {user_token}"),
        )
        assert edit_response.status_code == 404
        assert edit_response.json()["detail"] == "Template not found"

    def test_deploy(self, db_session, prompt_template, user_token, mocker):
        patch = mocker.patch("uberduck_py.routers.templates.aio_rate_limit")
        deploy_response = client.post(
            f"{self.endpoint}/prompts/{prompt_template.uuid}/deploy",
            json={"display_name": "Deployment Name"},
            cookies=dict(access_token=f"Bearer {user_token}"),
        )
        deploy_url_name = "deployment-name"

        assert equal_dicts(
            deploy_response.json(),
            {
                "url_name": deploy_url_name,
                "display_name": "Deployment Name",
                "variables": prompt_template.meta_json["variables"],
                "values": prompt_template.meta_json["values"],
                "prompt": prompt_template.prompt,
                "model": prompt_template.model,
            },
            ignore_keys=["created_at", "uuid", "completion"],
        )

        query = select(DBTemplateDeployment).filter(
            DBTemplateDeployment.url_name == deploy_url_name,
            DBTemplateDeployment.user_id == prompt_template.user_id,
        )
        deployed_prompt = db_session.execute(query).scalars().one()
        assert deployed_prompt.user_id == prompt_template.user_id
        assert deployed_prompt.url_name == deploy_url_name
        assert deployed_prompt.display_name == "Deployment Name"
        assert deployed_prompt.prompt == prompt_template.prompt
        assert deployed_prompt.created_at > prompt_template.created_at
        assert deployed_prompt.meta_json == prompt_template.meta_json
        assert deployed_prompt.model == prompt_template.model

    def test_deploy_overwrite(
        self, db_session, prompt_template2, deployment_template, user_token, mocker
    ):
        patch = mocker.patch("uberduck_py.routers.templates.aio_rate_limit")
        deploy_response = client.post(
            f"{self.endpoint}/prompts/{prompt_template2.uuid}/deploy",
            json={"display_name": "Test Template"},
            cookies=dict(access_token=f"Bearer {user_token}"),
        )
        assert deploy_response.status_code == 200
        assert deploy_response.json()["variables"] == ["test_var1"]

    def test_deploy_deleted(
        self, db_session, prompt_template_deleted, user_token, mocker
    ):
        patch = mocker.patch("uberduck_py.routers.templates.aio_rate_limit")
        deploy_response = client.post(
            f"{self.endpoint}/prompts/{prompt_template_deleted.url_name}/deploy",
            json={"display_name": "Test Template"},
            cookies=dict(access_token=f"Bearer {user_token}"),
        )
        assert deploy_response.status_code == 404
        assert deploy_response.json() == {"detail": "Template not found"}

    @pytest.mark.parametrize(
        "table,template_fixture",
        [
            ("deployments", "deployment_template"),
            ("prompts", "prompt_template"),
        ],
    )
    def test_template_generate(
        self, db_session, request, table, template_fixture, user_token, mocker
    ):
        patch = mocker.patch("uberduck_py.routers.templates.aio_rate_limit")
        template = request.getfixturevalue(template_fixture)
        identifier = template.url_name if table == "deployments" else template.uuid
        generation_response = client.post(
            f"{self.endpoint}/{table}/{identifier}/generate",
            json={
                "variables": {
                    "test_var1": "Whats",
                    "test_var2": "up",
                    "test_var3": "dude",
                },
            },
            cookies=dict(access_token=f"Bearer {user_token}"),
        )
        assert generation_response.status_code == 200
        assert len(generation_response.json()["choices"]) > 0

    @pytest.mark.parametrize(
        "table,template_fixture",
        [
            ("deployments", "deployment_template"),
            ("prompts", "prompt_template"),
        ],
    )
    def test_template_generate_wrong_vars(
        self, db_session, request, table, template_fixture, user_token, mocker
    ):
        patch = mocker.patch("uberduck_py.routers.templates.aio_rate_limit")
        template = request.getfixturevalue(template_fixture)
        identifier = template.url_name if table == "deployments" else template.uuid
        generation_response = client.post(
            f"{self.endpoint}/{table}/{identifier}/generate",
            json={
                "variables": {
                    "wrong_var1": "Whats",
                    "wrong_var2": "up",
                    "wrong_var3": "dude",
                },
            },
            cookies=dict(access_token=f"Bearer {user_token}"),
        )
        assert generation_response.status_code == 400
        assert list(generation_response.json().keys()) == ["detail"]
        message = generation_response.json()["detail"]
        assert "Missing the following variables" in message
        for var in "test_var1", "test_var2", "test_var3":
            assert var in message

    def test_deployment_generate(
        self, db_session, deployment_template, user_token, mocker
    ):
        patch = mocker.patch("uberduck_py.routers.templates.aio_rate_limit")
        generation_response = client.post(
            f"{self.endpoint}/deployments/test-template/generate",
            json={
                "variables": {
                    "test_var1": "Whats",
                    "test_var2": "up",
                    "test_var3": "dude",
                },
            },
            cookies=dict(access_token=f"Bearer {user_token}"),
        )
        assert generation_response.status_code == 200
        assert len(generation_response.json()["choices"]) > 0

    @pytest.mark.parametrize(
        "template_vars,input_vars,result,wrong_vars",
        [
            (
                ["input_1", "input_2", "input_3"],
                ["input_1", "input_2"],
                "missing",
                ["input_3"],
            ),
            ([], [], "OK", []),
            ([], ["input_1"], "extra", ["input_1"]),
            (["input_1"], ["wrong_name_1"], "missing", ["input_1"]),
            (
                ("input_1", "input_2"),
                ("input_1", "input_2", "input_3"),
                "extra",
                ["input_3"],
            ),
        ],
    )
    def test_check_variables(
        self, template_vars, input_vars, result, wrong_vars, mocker
    ):
        patch = mocker.patch("uberduck_py.routers.templates.aio_rate_limit")
        if result == "OK":
            check_variables(template_vars, input_vars)
        else:
            with pytest.raises(HTTPException) as excinfo:
                check_variables(template_vars, input_vars)
            message = excinfo.value.detail
            for wrong_var in wrong_vars:
                assert wrong_var in message
            if result == "missing":
                assert "Missing the following variables" in message
            else:
                assert "Specified variables not in template" in message
